---
title: "Módulo 4: Introducción a la Estadística en R"
title-slide-attributes:
  data-background-image: images/logo.jpeg
  data-background-size: contain
  data-background-opacity: "0.2"
author: 
  - name: Mauricio Moreno, PhD
logo: images/logo.jpeg
format: 
  revealjs:
    css: styles.css
    slide-number: true
    width: 1366
    preview-links: auto
    touch: true
    chalkboard:
      theme: whiteboard
      boardmarker-width: 4
      buttons: false
    revealjs-plugins:
      - pointer
---

# Antes de comenzar

## Generalidades {.smaller .scrollable}

::: incremental
-   Uno de los objetivos de este curso es el evitar en la medida de lo posible el adentrarnos en teoría estadística. Entre los temas que dejaremos de lado están:

    -   Teoría de la probabilidad básica

    -   Ley de los números grandes

    -   Distribución muestral (o de muestreo)

    -   Teorema del límite central

    -   Descripción a detalle de la distribución normal

    -   Descripción a detalle de otras distribuciones

    -   Análisis de poder

    -   Pruebas para valores discretos univariados

        -   Prueba de bondad de ajuste de $\chi^2$

    -   Pruebas para valores discretos bivariados

        -   Prueba de independencia de $\chi^2$

        -   Prueba exacta de Fisher

-   Sin embargo, es preciso el comenzar por algunas definiciones que inevitablemente serán necesarias para entender de mejor manera el resto del mismo.

-   Para esta sesión vamos a instalar nuevos paquetes: `"UsingR", "datarium", "rstatix", "car", "ggeffects", "emmeans", "multcomp", "multcompView", "olsrr", "ggpubr"`


-   Para quién esté interesado en un recurso para ver estos temas a profundidad, recomiendo el libro de [Danielle Navarro: *Learning Statistics with R*](https://learningstatisticswithr.com/){target="_blank"}

:::

# Definiciones básicas

## Muestras, poblaciones y muestreos

::: incremental
-   **Muestra**: Es un conjunto de observaciones que provienen de una población de interés. Idealmente, esta debería ser lo suficientemente grande para hacer inferencias de esa población.

-   **Población**: Es el conjunto de todas las posibles observaciones de las que tengamos interés en realizar inferencias. Es vital el definir adecuadamente sus características.

-   **Muestreo**: Es el proceso por el cual obtendremos nuestra muestra para un estudio. En estudios experimentales, el muestreo se entiende también como el proceso de aleatorización/randomización de unidades experimentales.
:::

## Muestreo simple sin reemplazo

![Tomado de [*Learning Statistics with R*](https://learningstatisticswithr.com/){target="_blank"}](images/simple1.png){fig-align="center" width="900"}

## Muestreo simple con reemplazo

![Tomado de [*Learning Statistics with R*](https://learningstatisticswithr.com/){target="_blank"}](images/simple2.png){fig-align="center" width="1020"}

## Otros tipos de muestreo

::: incremental
-   **Muestreo sistemático**: consiste en tomar un determinado elemento de la población siguiendo un patrón. Por ejemplo, escoger los múltiplos de cuatro enumerados en una lista de posibles individuos de estudio (solía ser una práctica común en ensayos clínicos).

-   **Muestreo a conveniencia**: consiste en incluir en el estudio a todos los elementos disponibles de la población de interés. Esto sucede sobre todo con poblaciones escasas o de dificil acceso (ejemplo, realizar estudios en comunidades LGBTIQ+).

-   **Muestreo estratificado**: es una combinación del muestreo simple con los sujetos agrupados por alguna característica en común, por ejemplo sexo, edad, hábitat (suele ser usado en exit polls y conteos rápidos).
:::

## Parámetros poblacionales y estadísticos muestrales

::: incremental
-   Los parámetros poblacionales son características de toda una población (ejemplo, supongamos que el IQ de toda una población puede estar caracterizado por una media aritmética, $\mu$, igual a 100, con una desviación estándar, $\sigma$, igual a 15).

-   Si tomo una muestra de 100 individuos de dicha población, podría tener una media aritmética de esta muestra, $\overline{X}$, igual a 101.4 y una desviación estándar de la muestra, $s$, igual a 13.7.

-   En otras palabras, la $\overline{X}$ y $s$ son aproximaciones a los valores verdareros de $\mu$ y $\sigma$ de esa población.
:::

## Estimación de parámetros de población {.smaller}

**Media aritmética**

| Símbolo        | ¿Qué es?                                        | ¿Sabemos qué es?              |
|----------|------------------------------------|----------------------|
| $\overline{X}$ | Media aritmética de la muestra                  | Calculada de los datos        |
| $\mu$          | Verdadera media aritmética de la población      | Casi nunca es conocida        |
| $\hat{\mu}$    | Estimado de la media aritmética de la población | Sí, identica a $\overline{X}$ |

$$
\overline{X} = \frac{1}{n}\sum^{n}_{i=1}\left(X_i\right)
$$

## Estimación de parámetros de población {visibility="uncounted" .smaller}

**Desviación estándar**

| Símbolo        | ¿Qué es?                                          | ¿Sabemos qué es?           |
|---------|---------------------------------------|---------------------|
| $s$            | Desviación estándar de la muestra                 | Calculada de los datos     |
| $\sigma$       | Verdadera desviación estándar de la población     | Casi nunca es conocida     |
| $\hat{\sigma}$ | Estimado de la deviación estándar de la población | Sí, pero no es igual a $s$ |

::: columns
::: {.column width="50%"}
$$
s = \sqrt{\frac{1}{n} \sum_{i=1}^n (X_i - \overline{X})^2} 
$$
:::

::: {.column width="50%"}
$$
\sigma = \sqrt{\frac{1}{n-1} \sum_{i=1}^n (X_i - \overline{X})^2} 
$$
:::
:::

## Estimación de parámetros de población {visibility="uncounted" .smaller}

**Varianza**

| Símbolo          | ¿Qué es?                                | ¿Sabemos qué es?             |
|----------|-------------------------------|------------------------|
| $s^2$            | Varianza de la muestra                  | Calculada de los datos       |
| $\sigma^2$       | Verdadera varianza de la población      | Casi nunca es conocida       |
| $\hat{\sigma}^2$ | Estimado de la varianza de la población | Sí, pero no es igual a $s^2$ |

::: columns
::: {.column width="50%"}
$$
s^2 = \frac{1}{n} \sum_{i=1}^n (X_i - \overline{X})^2
$$
:::

::: {.column width="50%"}
$$
\sigma^2 = \frac{1}{n-1} \sum_{i=1}^n (X_i - \overline{X})^2 
$$
:::
:::

## Intervalos de confianza {.smaller}

::: incremental
-   Cómo hemos visto, los estimados de las verdaderas $\mu$ y $\sigma$ ($\hat{\mu}$ y $\hat{\sigma}$) provienen de distribuciones de muestreo, y como tales, inherentemente poseen cierto grado de incertidumbre.

-   Los intervalos de confianza son medidas que nos permiten tener una idea de esa incertidumbre.

-   En el estudio de la distribución normal estándar tenemos el conocimiento que existe un 95% de chances que una cantidad normalmente distribuida colectada al azar, estará distante de la media aritmética entre $\pm$ 1.96 desviaciones estándar.
:::

. . .

$$
\overline{X} - \left(1.96\times\frac{\sigma}{\sqrt{n}}\right) \leq \mu \leq \overline{X} + \left(1.96\times\frac{\sigma}{\sqrt{n}}\right)
$$

::: incremental
-   Y se interpreta como: **con un 95% de confianza, podemos esperar que la media aritmética verdadera de la población de interés se encuentra contenida entre...**
:::

. . .

$$
\text{IC}_{95}=\overline{X} \pm \left(1.96\times\frac{\sigma}{\sqrt{n}}\right) 
$$

## Intervalos de confianza {.smaller visibility="uncounted"}

::: incremental
-   Sin embargo, como mencionamos $\sigma$ es casi nunca conocido, y es necesario hacer una corrección a la fórmula anterior. La distribución normal trabaja bien baja la presunción de un numero grande de observaciones.

-   En su lugar, en 1908 el estadístico [Gosset](https://en.wikipedia.org/wiki/Student%27s_t-distribution){target="_blank"} parametrizó una distribución para muestras pequeñas que asemeja a la normal. Con el tiempo, esta distribución adoptó el nombre de *Student*.

-   Y es precisamente que la fórmula anterior es corregida con la distribución de Student y así poder calcular intervalos de confianza para muestras pequeñas usando $s$ en lugar de $\sigma$:
:::

. . .

$$
\text{IC}_{95}=\overline{X} \pm \left(t_{n-1,\alpha/2}\times\frac{s}{\sqrt{n}}\right) 
$$

::: incremental
-   Donde el valor $t_{n-1,\alpha/2}$ refiere a:

    -   $n-1$: los grados de libertad, igual al número de observaciones $n$ de la muestra, menos 1

    -   $\alpha$: es el nivel de significancia (probabilidad de obtener un resultado erróneo por azar).

    -   Estos valores en el pasado se encontraban tabulados en libros de texto, hoy contamos con R!
:::

## Intervalos de confianza {visibility="uncounted" autoanimate="true"}

::: incremental
-   Regresando al ejemplo del IQ, supongamos que medimos al azar el IQ de 5 personas y deseamos calcular el $\text{IC}_{95}$
:::

. . .

```{r echo=T, eval=T, error=T}
#| code-line-numbers: "1|2|3|4|5|6|7"
IQ_muestra <- c(101, 98, 116, 96, 129)   # muestra
n <- 5                                   # número de observaciones
t95 <- qt(p = 0.975, df = n -1)          # valor de Student para 4 grados de libertad al 5%
x <- mean(IQ_muestra)                    # media aritmética de la muestra
s <- sd(IQ_muestra)                      # desviación estándar de la muestra
ls <- x + (t95*s/(n-1))                  # límite superior del IC95
li <- x - (t95*s/(n-1))                  # límite inferior del IC95
```

## Intervalos de confianza {autoanimate="true" visibility="uncounted"}

-   Regresando al ejemplo del IQ, supongamos que medimos al azar el IQ de 5 personas y deseamos calcular el $\text{IC}_{95}$

```{r echo=T, eval=T, error=T}
#| code-line-numbers: "8"
IQ_muestra <- c(101, 98, 116, 96, 129)   # muestra
n <- 5                                   # número de observaciones
t95 <- qt(p = 0.975, df = n -1)          # valor de Student para 4 grados de libertad al 5%
x <- mean(IQ_muestra)                    # media aritmética de la muestra
s <- sd(IQ_muestra)                      # desviación estándar de la muestra
ls <- x + (t95*s/(n-1))                  # límite superior del IC95
li <- x - (t95*s/(n-1))                  # límite inferior del IC95
print(paste0("Con un 95% de confianza podemos esperar que la verdadera media aritmética de IQ de esta población se encuentre entre [",round(li,0),", ",round(ls,0),"]"))
```

## Autoevaluación \# 9 {.smaller .scrollable}

La concentración media de glucosa en ratones sanos se ha estimado en un rango entre 80 y 100 mg/dL. En un experimento, se han medido las siguientes concentraciones de glucosa en 10 ratones de una línea genética se presume tendría potencial de ser modelo de hiperglucemia después de unas cuantas más generaciones de cruce selectivo:

```{r echo=T, eval=F, error=T}
glc_rat <- c(108.7, 93.7, 52.7, 79.0, 74.7, 131.9, 99.5, 63.3, 98.6, 92.7)
```

::: columns
::: {.column width="70%"}
1.  La media aritmética $\overline{X}$ de la muestra es:
:::

::: {.column width="30%"}
a)  89.5
b)  85.5
c)  91.8
d)  100.1
:::
:::

::: columns
::: {.column width="70%"}
2.  La desviación de estándar $s$ de la muestra es
:::

::: {.column width="30%"}
a)  30.6
b)  18.0
c)  15.6
d)  22.7
:::
:::

::: columns
::: {.column width="70%"}
3.  El intervalo de confianza (bajo la distribución de Student) es
:::

::: {.column width="30%"}
a)  \[81.4, 95.3\]
b)  \[80.4, 97.3\]
c)  \[83.7, 95.3\]
d)  \[83.7, 100.3\]
:::
:::

# Pruebas de hipótesis

## Hipótesis de investigación vs. hipótesis estadísticas {.smaller}

::: incremental
-   Una hipótesis de investigación gira alrededor del desarrollar una conclusión científica acerca de un tema de interés del investigador. Ejemplos: *el fumar causa cáncer*, *las vacunas causan/previenen enfermedades*.

    -   Es decir, pueden tener una naturaleza subjetiva, que expresan la pregunta del investigador de una manera general sin mayor descripción del ¿cómo? voy a probar o descartarla, ni ¿en qué extensión?.

-   Hipótesis estadísticas, por el contrario, deben ser matemáticamente precisas y basadas en las características de los datos que recolectemos con el fin de probar o descartar la hipótesis de investigación.

    -   Cómo es de esperar, el probar o descartar una hipótesis estadística será únicamente válida para la población sobre la cual una muestra fue tomada.

    -   Es ahí donde radica la importancia en definir la población sujeto de estudio de manera planificada con el objetivo de que cumpla tantos detalles sean necesarios de la hipótesis de investigación. Ejemplo, el modelo animal más usado es el ratón. Si bien es cierto constituye uno de los primeros pasos en el desarrollo de muchas investigaciones, los hallazgos en ratones NO pueden ser inmediatamente atribuibles a suceder en seres humanos.
:::

## Hipótesis nula y alternativa {.smaller}

::: incremental
-   La formulación de hipótesis estadísticas puede reducirse a establer preguntas de investigación en forma de las hipótesis nula y alternativa.

-   La más sencilla manera de formular esta dupla, es la siguiente. Supongamos que tenemos dos grupos experimentales para probar la eficiencia de un nuevo procedimiento quirúrgico. Un grupo de pacientes será sometido a la intervención tradicional (control), y el otro grupo al nuevo procedimiento (experimental).

    -   La hipótesis nula ($H_0$) establece que: no existe diferencia entre el grupo control y el grupo experimental,

    -   Mientras que la hipótesis alternativa ($H_a$) establece que: sí existe differencia entre ambos.
:::

. . .

```{=tex}
\begin{align}
H_0& : \mu_c = \mu_e& H_0& : \mu_c- \mu_e =0 \\
H_a& : \mu_c \neq \mu_e& H_a& : \mu_c- \mu_e \neq 0
\end{align}
```
## Tipos de errores

::: incremental
-   Al llevar a cabo pruebas de hipótesis pueden ocurrir errores
:::

. . .

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(xtable)
```

```{r, results='asis'}
dat <- data.frame(
  " " = c("H_{0}\\text{ es verdadera}", "H_{0}\\text{ es falsa}"),
  "\\text{Acepta }H_{0}" = c("\\text{Desición correcta}", "\\text{Error tipo II}"),
  "\\text{Rechaza }H_{0}" = c("\\text{Error tipo I}", "\\text{Desición correcta}"),
  check.names = FALSE
)

M <- print(xtable(dat, align=rep("|c|", ncol(dat)+1)), 
           floating = FALSE, tabular.environment="array", 
           comment=FALSE, print.results=FALSE, 
           include.rownames = FALSE,
           sanitize.text.function = function(x) x)
cat(M)
```

. . .

-   ¿De qué depende que aceptemos correctamente o no la hipótesis nula?

. . .

Las pruebas estadísticas dependen de la cantidad de variación y la diferencia entre tratamientos a detectar (**tamaño del efecto**). La solución: aumentar el número de observaciones

## Poder de una prueba estadística {.smaller}

::: incremental
-   El poder de una prueba estadística es la probabilidad de rechazar la hipótesis nula cuando esta es de hecho falsa.

-   Se puede derivar de la tabla anterior
:::

. . .

```{r, results='asis'}
dat <- data.frame(
  " " = c("H_{0}\\text{ es verdadera}", "H_{0}\\text{ es falsa}"),
  "\\text{Acepta }H_{0}" = c("1-\\alpha\\text{ (Prob. decisión correcta)}", "\\beta\\text{ (Taza Error tipo II)}"),
  "\\text{Rechaza }H_{0}" = c("\\alpha\\text{ (Taza Error tipo I)}", "1-\\beta\\text{ (Poder)}"),
  check.names = FALSE
)

M <- print(xtable(dat, align=rep("|c|", ncol(dat)+1)), 
           floating = FALSE, tabular.environment="array", 
           comment=FALSE, print.results=FALSE, 
           include.rownames = FALSE,
           sanitize.text.function = function(x) x)
cat(M)
```

. . .

-   En la práctica, existen fórmulas cerradas para la determinación del número mínimo de observaciones para alcanzar un poder adecuado ($\ge$ 80%).

-   A este procedimiento se le conoce como análisis de poder. Este se lo puede realizar en R, por supuesto, pero no es parte de nuestro curso.

## Tamaño del efecto {.smaller}

::: incremental
-   El tamaño del efecto ($\theta$) es un valor que por lo general es determinado por el investigador y que puede ser la diferencia de interés a detectar en una prueba estadística.

-   Por simplicidad, vamos a enfocarnos en el ejercicio de los ratones. Supongamos que el investigador está interesado en saber cual sería el número de ratones que necesitaría para con un 80% de poder, encontrar una diferencia entre la media aritmética de su muestra y un valor que considera razonable chequear igual a 100 mg/dL. Este último valor viene a ser el $\theta$.

-   Las hipótesis de esta prueba se verían así
:::

. . .

```{=tex}
\begin{align}
H_0& : \mu_c- \mu_r = \theta \\
H_a& : \mu_c- \mu_r \neq \theta
\end{align}
```
::: incremental
-   Sin embargo, la pregunta del investigador aún está incompleta. [**A tu criterio, ¿qué falta?**]{.fragment}

-   Al formular hipótesis, hemos considerado el caso más simple hasta el momento. Pero recordando la idea inicial del experimento de los ratones, la opción lógica sería preguntarnos ¿cuántos ratones necesitamos para estar seguros que la población sea hiperglucémica? (cuyo valor de glucosa en sangre esté por encima del de un ratón sano)
:::

## Pruebas de dos colas

```{=tex}
\begin{align}
H_0& : \mu_c- \mu_r = \theta \\
H_a& : \mu_c- \mu_r \neq \theta
\end{align}
```
![Imagen tomada de [*UCLA: Advanced Research Computing*](https://stats.oarc.ucla.edu/other/mult-pkg/faq/general/faq-what-are-the-differences-between-one-tailed-and-two-tailed-tests/){target="_blank"}](images/dcolas.gif){fig-align="center" width="400"}

## Pruebas de una cola

```{=tex}
\begin{align}
H_0& : \mu_c- \mu_r \ge \theta \\
H_a& : \mu_c- \mu_r < \theta
\end{align}
```
![Imagen tomada de [*UCLA: Advanced Research Computing*](https://stats.oarc.ucla.edu/other/mult-pkg/faq/general/faq-what-are-the-differences-between-one-tailed-and-two-tailed-tests/){target="_blank"}](images/ucolagreat.gif){fig-align="center" width="400"}

## Pruebas de una cola {visibility="uncounted"}

```{=tex}
\begin{align}
H_0& : \mu_c- \mu_r \le \theta \\
H_a& : \mu_c- \mu_r > \theta
\end{align}
```
![Imagen tomada de [*UCLA: Advanced Research Computing*](https://stats.oarc.ucla.edu/other/mult-pkg/faq/general/faq-what-are-the-differences-between-one-tailed-and-two-tailed-tests/){target="_blank"}](images/ucolaless.gif){fig-align="center" width="400"}

## Valores críticos y el valor p

::: incremental
-   Pero ¿cómo sabemos si una hipótesis es aceptada o rechazada?

-   Regresando al concepto de los intervalos de confianza, los cuartiles de la distribución de Student calculados a un nivel de significancia $\alpha$ son valores críticos sobre los cuales se determina el rechazo o aceptación de la hipótesis nula.

-   El valor p, describe que tan probable sería observar resultados de la prueba asumiendo que la hipótesis nula no hubiese sido rechazada. Por ello, a menores valores p, mayor la diferencia estadística con respecto a la hipótesis alternativa.
:::

## Antes de continuar

![](images/cena.png){fig-align="center"}

::: footer
Imagen tomada de [aquí](https://arbor-analytics.com/post/2022-10-10-p-ing-in-the-woods-p-values-in-forest-science/){target="_blank"}
:::

## Antes de continuar {.smaller visibility="uncounted"}

::: incremental
-   El umbral de 0.05 es una convención arbitraria [creada por Fischer](https://www.bmj.com/rapid-response/2011/11/03/origin-5-p-value-threshold#:~:text=statistician%20RA%20Fisher%20in%201926%20%5B1%5D.){target="_blank"} en los inicios de la estadística moderna.

-   Lastimosamente, se ha generalizado la idea de que por más mínima sea la diferencia con respecto a 0.05, esta representa la diferencia entre publicar o no (en el campo académico), entre lanzar o no un nuevo fármaco/producto al mercado (en la industria).

-   En 2014, debido a un fallo de la [corte suprema de justicia de los Estados Unidos](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5017929/#:~:text=A%20statistically%20significant%20test%20result,that%20no%20effect%20was%20observed.){target="_blank"} que le dio la potestad a los inversionistas de farmaceúticas a demandarlas por fallar en reportar efectos secundarios de sus productos a pesar de haber sido hallados estadísticamente no significativos, la Asociación Americana de Estadística (ASA) se vio en la necesidad de definir más exhaustivamente el concepto del valor p.

-   Entre las recomendaciones de la ASA, se enfatizó el dar mayor prioridad a la estimación de otros estadísticos complementarios al valor p, tales como intervalos de confianza u otros provenientes de la estadística Bayesiana (intervalos de credibilidad, factores de Bayes).

-   Esta última (estadística Bayesiana), ofrece una interpretación más natural de la estadística al poder interpretar todos sus resultados en términos de probabilidades y no en números arbirtrarios como el valor p.

-   En resumen, una investigación no es inútil si el valor p sobrepasa o está por debajo de 0.05 por cantidades pequeñas.
:::

## Antes de continuar {.smaller .smaller visibility="uncounted"}

::: incremental
-   En su lugar, en escenarios en que el valor p está alejado por una décima o varias centésimas de 0.05, los resultados deberían interpretarse como indeterminados para generalizar sobre la población objeto de estudio y específicos a las condiciones experimentales (análisis estadísticos, instrumentos de medición, etc) bajo las cuales fueron tomadas y modeladas las mediciones.

-   En el contexto de los modelos estadísticos que veremos más adelante, esto ha derivado en un "temor" del investigador cuando los resultados no pasan los chequeos de los supuestos sobre los que estos modelos se cimentan. Sobre todo cuando el valor p dista de 0.05 por ínfimas cantidades.

-   Esto puede llevar a malas prácticas científicas tales como: no reportar el resultado de los chequeos, blindar los datos, escoger "outliers" y removerlos y en el peor de los casos, manipular los datos para tratar de acomodar nuestros datos a estos chequeos.

-   Todo lo que he mencionado, no solamente constituyen casos de mala conducta científica, sino lo que hoy en día se le conoce como *p hacking* (que se puede resumir a torturar los datos hasta que nos confiesen una verdad agradable a nuestros propósitos).
:::

# Pruebas estadísticas paramétricas

## Datos para esta sección

::: incremental
-   Para esta sección del curso usaremos algunas de las tablas de datos del libro [*Using R for Introductory Statistics*](https://www.routledge.com/Using-R-for-Introductory-Statistics/Verzani/p/book/9781466590731#:~:text=Resources%20Support%20Material-,Book%20Description,small%2C%20task%2Doriented%20steps.){target="_blank"}, como también del paquete `datarium`.

-   Para ello, instalaremos los paquetes de R: `UsingR` y `datarium`.
:::

. . .

```{r echo=T, eval=T, error=T}
library(UsingR)
library(datarium)
```

## Pruebas t {.smaller}

::: incremental
-   Las pruebas t son usadas para encontrar la diferencia entre dos medias aritméticas.

-   La $H_0$ en estas pruebas es que las medias aritméticas son las mismas.

-   Se rechaza la $H_0$ cuando el valor p resultante es $<$ 0.05

-   Existen tres tipos de pruebas t

    -   Pruebas t de una muestra

    -   Pruebas t de muestras independientes

    -   Pruebas t de muestras emparejadas

-   Estas pruebas fueron desarrolladas bajo la suposición de la **normalidad** y de **homogeneidad de las varianzas**.

-   De acuerdo al teorema del límite central, muestras grandes casi aseguran la normalidad.

-   Cuando el número de observaciones en una muestra es pequeño, es recomendable llevar a cabo un test de normalidad para decidir si es posible una prueba t o una de sus alternativas.
:::

## Normalidad de una muestra

::: incremental
-   Antes de llevar a cabo las pruebas t, hemos mencionado sus supuestos. Por ello, es aconsejable el siempre realizar estas pruebas antes de usarlas.

-   Existen dos tipos de pruebas para establecer si una muestra es normalmente distribuida o no

    -   Indirectamente: gráfico Q-Q

    -   Prueba formal de normalidad (ejemplo: Shapiro-Wilk)

-   **En el caso del ANOVA**, es importante enfatizar que estas pruebas no necesariamente tienen que hacerse antes de la prueba, como ya veremos más adelante.
:::

## Gráfico Q-Q

::: incremental
-   El gráfico Q-Q es una prueba visual indirecta de la normalidad.

-   Consiste en crear un gráfico de dispersión entre los valores observados de una muestra vs. los valores que deberían estos tener si siguieran una distribución normal.

-   Mientras en el gráfico de dispersión los puntos más se distribuyan a lo largo de una diagonal, más cercanos están los datos de la muestra a seguir un distribución normal.

-   Su desventaja es que es muy subjetivo, y a menudo requiere una prueba formal para poder confirmarlo.
:::

## Gráfico Q-Q {visibility="uncounted"}

```{r echo=T, eval=F, error=T, fig.width=6, fig.align='center'}
#| code-line-numbers: "1|2|3"
set.seed(123)
y <- rnorm(n = 30, mean = 0, sd = 1)  # simulamos 30 observaciones de una normal estandar
qqnorm(y)                             # producimos el gráfico Q-Q
```

## Gráfico Q-Q {visibility="uncounted"}

```{r echo=T, eval=T, error=T, fig.width=6, fig.align='center'}
set.seed(123)
y <- rnorm(n = 30, mean = 0, sd = 1)  # simulamos 30 observaciones de una normal estandar
qqnorm(y)                             # producimos el gráfico Q-Q
```

## Prueba de normalidad Shapiro-Wilk

::: incremental
-   La $H_0$ de esta prueba (y del resto de pruebas formales de normalidad) es que un set de $n$ observaciones es normalmente distribuido.

-   Otro conocido método es Kolmogorov-Smirnov. Sin embargo, Shapiro-Wilk es más apropiado para cuando el número de muestras es menor a 50.

-   Para ilustrar su uso, chequeemos la normalidad de los datos que simulamos anteriormente
:::

. . .

```{r echo=T, eval=T, error=T, fig.width=6, fig.align='center'}
shapiro.test(y)
```

## Prueba de homogeneidad de las varianzas {.smaller}

::: incremental
-   En el caso de comparaciones entre las medias de dos grupos, la homogeneidad de varianzas puede chequearse usando la prueba F.

-   La prueba t de una muestra no requiere chequear este supuesto.

-   Para ilustrar su uso, creemos otro vector con datos simulados. En este caso, un igual número de observaciones con la misma desviación estándar pero diferente media:
:::

. . .

```{r echo=T, eval=T, error=T, fig.width=6, fig.align='center'}
set.seed(123)
x <- rnorm(n = 30, mean = 4, sd = 1)
var.test(x, y)
```

## Supuestos en la práctica {.scrollable}

::: incremental
-   Usemos las pruebas con datos reales, esta vez con la tabla de datos `crime` del paquete `Using R`.

-   Esta tabla de datos contiene registros de las tasas de crimen (# de reportes/100000 habitantes) en 50 estados en los Estados Unidos correspondiente a los años 1983 y 1993.

-   Sin enfocarnos por el momento en que prueba t específica usaremos, limitémonos a chequear la normalidad y la homogeneidad de varianzas entre las tasas de crimen registradas en 1983 y 1993.
:::

. . .

```{r echo=T, eval=T, error=T}
data(crime)
```

::: columns
::: {.column .fragment width="50%"}
Normalidad 1983

```{r echo=T, eval=T, error=T}
shapiro.test(crime$y1983)     
```
:::

::: {.column .fragment width="50%"}
Normalidad 1993

```{r echo=T, eval=T, error=T}
shapiro.test(crime$y1993)     
```
:::
:::

. . .

Homogeneidad de las varianzas

```{r echo=T, eval=T, error=T, fig.width=6, fig.align='center'}
var.test(crime$y1983, crime$y1993)
```

![](images/calmarno.jpg){fig-align="center"}

## Transformación de variables

::: incremental
-   A menudo nos encontraremos con conjuntos de observaciones que no cumplen uno o ninguno de los supuestos.

-   Antes de considerar pruebas no paramétricas, podemos intentar transformaciones de variables para regresar al mundo de las pruebas paramétricas. Las transformaciones más usadas son:

    -   La raíz cuadrada (si los datos no contienen números negativos)

    -   Elevar al cuadrado

    -   Logaritmo (si los datos solo incluyen números reales positivos, cero excluido)
:::

## Transformación de variables {visibility="\"uncounted"}

::: incremental
-   Existe un método más sofisticado para "normalizar" una muestra. [[La transformación de Box-Cox.](https://www.r-bloggers.com/2022/10/box-cox-transformation-in-r/)]{.fragment}

-   Cuando se trabaja con muestras transformadas, el objetivo es poder revertir la transformación a las unidades reales para así poder hacer conclusiones sobre las inferencias estadísticas.

-   En otras palabras, una misma transformación **debe** aplicarse a todos los grupos a ser comparados. **NO** tiene ningún sentido tratar de realizar inferencias entre grupos donde se hayan usado distintas transformaciones para normalizarlos.

-   Si el número de observaciones es muy reducido, usualmente no hay transformación que funcione y se recomienda usar directamente pruebas no paramétricas.
:::

## Transformación de variables {.scrollable visibility="\"uncounted"}

::: columns
::: {.column .fragment width="50%"}
Raíz cuadrada

```{r echo=T, eval=T, error=T}
shapiro.test(sqrt(crime$y1983))     
```
:::

::: {.column .fragment width="50%"}
Elevar al cuadrado

```{r echo=T, eval=T, error=T}
shapiro.test(crime$y1983^2)     
```
:::
:::

::: columns
::: {.column .fragment width="50%"}
Logaritmo

```{r echo=T, eval=T, error=T}
shapiro.test(log(crime$y1983))     
```
:::

::: {.column .fragment width="50%"}
Chequeemos con el otro grupo

```{r echo=T, eval=T, error=T}
shapiro.test(log(crime$y1993))     
```
:::
:::

. . .

Homogeneidad de las varianzas con transformación logarítmica

```{r echo=T, eval=T, error=T, fig.width=6, fig.align='center'}
var.test(log(crime$y1983), log(crime$y1993))
```

![](images/kid.jpg){fig-align="center"}

## Prueba t de una muestra

::: incremental
-   Es usada para comparar la media aritmética de una muestra con un valor conocido (un estándar por ejemplo).

-   Por lo general el valor al que se va a comparar proviene de referencias bibliográficas, pre-experimentos o supociones fundamentadas.

-   En este caso, el supuesto que debe cumplirse es el de la normalidad de los datos

-   Regresando a nuestro ejemplo de los ratones, determinemos si la media de la muestra es mayor al límite superior de glucosa de ratones saludables.
:::

## Prueba t de una muestra {visibility="uncounted" autoanimate="true"}

```{r echo=T, eval=F, error=T}
#| code-line-numbers: "1|2|3|4"
glc_rat <- c(108.7, 93.7, 52.7, 79.0, 74.7, 131.9, 99.5, 63.3, 98.6, 92.7)
t.test(glc_rat,
       mu = 100,
       alternative = "greater")
```

## Prueba t de una muestra {visibility="uncounted" autoanimate="true"}

```{r echo=T, eval=T, error=T}
glc_rat <- c(108.7, 93.7, 52.7, 79.0, 74.7, 131.9, 99.5, 63.3, 98.6, 92.7)
t.test(glc_rat,
       mu = 100,
       alternative = "greater")
```

## Prueba t de muestras independientes

::: incremental
-   Es usado para comparar las medias aritméticas de dos grupos independientes.

-   Por ejemplo, si deseas comparar las medias aritméticas de individuos agrupados por sexo.

-   Para ilustrar esta prueba, vamos a hacer uso de la tabla de datos de `genderweight` del paquete `datarium`.

    -   Veamos si existe una diferencia significativa en la media del peso entre hombres y mujeres
:::

. . .

```{r echo=T, eval=T, error=T}
data(genderweight)
```

## Prueba t de muestras independientes {.scrollable .smaller visibility="uncounted"}

::: columns
::: {.column .fragment width="50%"}
Chequeamos normalidad: Group M

```{r echo=T, eval=T, error=T}
shapiro.test(subset(genderweight, group == "M")$weight)     
```
:::

::: {.column .fragment width="50%"}
Chequeamos normalidad: Group F

```{r echo=T, eval=T, error=T}
shapiro.test(subset(genderweight, group == "F")$weight)     
```
:::
:::

. . .

Chequeamos la homogeneidad de las varianzas

```{r echo=T, eval=T, error=T}
var.test(genderweight$weight ~ genderweight$group)
```

::: incremental
-   **¡La homogeneidad de las varianzas no se cumple!** 😱

-   ¿Debemos transformar? [No necesariamente]{.fragment}

-   El no cumplir con el supuesto de la homogeneidad de varianzas no es un gran problema gracias a varias correcciones.

-   La función base de R `t.test` cuenta con el argumento `var.equal = F` como default.

-   Bajo este argumento, no se asumen varianzas iguales entre los grupos y en su lugar R lleva a cabo la aproximación de Welch para lidiar con este problema.
:::

## Prueba t de muestras independientes {visibility="uncounted"}

```{r echo=T, eval=T, error=T}
t.test(genderweight$weight ~ genderweight$group)
```

## Prueba t para muestras emparejadas

::: incremental
-   Es usado para comparar las medias de dos grupos que guardan una relación.

-   Esto solo ocurre cuando las medidas se han realizado a partir de los mismos grupos. Por ejemplo, al inicio y al final de un experimento.

-   Para esta prueba, vamos a usar la tabla de datos `crime` del paquete `UsingR`

    -   Veamos si existe una diferencia en las tasas de crimen (# de reportes/100000 habitantes) en 50 estados de los Estados unidos entre 1983 y 1993
:::

. . .

```{r echo=T, eval=T, error=T}
data(crime)
```

## Prueba t para muestras emparejadas {visibility="uncounted" autoanimate="true"}

```{r echo=T, eval=F, error=T}
#| code-line-numbers: "1|2|3"
t.test(x = log(crime$y1983), y = log(crime$y1993), paired = TRUE)
exp(mean(log(crime$y1983)))
exp(mean(log(crime$y1993)))
```

## Prueba t para muestras emparejadas {visibility="uncounted" autoanimate="true"}

```{r echo=T, eval=T, error=T}
t.test(x = log(crime$y1983), y = log(crime$y1993), paired = TRUE)
exp(mean(log(crime$y1983)))
exp(mean(log(crime$y1993)))
```

## Autoevaluación \# 10 {.smaller .scrollable}

En esta autoevaluación, usaremos tablas de datos del paquete `UsingR` y `datarium`:

1)    La tabla de datos `blood` (paquete `UsingR`) tiene las medidas de presión sistólica de sangre correspondientes a 15 pacientes (columna "machine"). De acuerdo al Centro de Prevención y Control de Enfermedades de los Estados Unidos (CDC), una presión sistólica saludable está por debajo de 120 mm Hg. Determina si la media de la muestra contenida en esta tabla de datos está por debajo de este valor sugerido por el CDC.

```{r echo=T, eval=F, error=T}
data(blood)
blood
```

2)    La tabla de datos `normtemp` (paquete `UsingR`) tiene las medidas en grados Fahrenheit de temperatura corporal (columna "temperature" ) correspodientes a 65 mujeres y 65 hombres (columna "gender"). Determina si existe una diferencia entre las temperaturas corporales de hombres y mujeres.

```{r echo=T, eval=F, error=T}
data(normtemp)
normtemp
```

3)    La tabla de datos `mice2` (paquete `datarium`) tiene las medidas del peso de 10 ratones antes y después de haber sido sometidos a una determinada dieta. Encuentra si existe una diferencia significativa en el peso de estos ratones antes y después del régimen de dieta al que fueron expuestos. ¿Ganaron o perdieron peso?


```{r echo=T, eval=F, error=T}
data(mice2)
mice2
```

4)    En el paquete `UsingR` tenemos disponible una lista con 5 objetos bajo el nombre `cancer`. Esta contiene el tiempo de sobreviviencia en días de pacientes con distintos tipos de cáncer desde el momento de su diagnóstico hasta su deceso. Chequea si los datos correspondientes a cáncer de colon son normalmente distribuidos. Si no lo son, prueba si puedes normalizarlos usando alguna de las tres transformaciones que vimos. En el caso que más de una transformación funcione, ¿cuál escogerías para continuar con alguna prueba estadística, y por qué?

**Tip: usa el siguiente código para extraer en un vector los datos de pacientes con cáncer de colon:**

```{r echo=T, eval=T, error=T}
data(cancer)
colon <- cancer$colon
```

# Pruebas estadísticas no paramétricas

## Pruebas de Wilcoxon para datos no normales

::: incremental
-   Las pruebas de Wilcoxon usan la mediana como criterio para evaluar la $H_0$.

-   Lastimosamente, estas pruebas son usualmente menos poderosas (mayor tasa de errores tipo II).

-   Tiene dos formas:

    -   Pruebas para una muestra (análoga a la prueba t para una muestra)

    -   Pruebas para dos muestras (análoga a las pruebas t para dos muestras independientes y emparejadas)
:::

## Prueba de Wilcoxon para una muestra

::: incremental
-   [Prof. Danielle Navarro](https://learningstatisticswithr.com/){target="_blank"} midió el nivel de felicidad de sus estudiantes antes y después de su clase de Estadística. Ella estaba interesada en saber si el tomar una clase de Estadística tiene algún efecto en la felicidad de sus estudiantes. Los datos que obtuvo no están normalmente distribuidos. Por ello, se vio en la necesidad de llevar a cabo una prueba de Wilcoxon.

-   En este caso, la $H_0$, es que la diferencia de la mediana de la felicidad de sus estudiantes antes y después de la clase debería ser igual a cero para clamar que no existe tal efecto.
:::

## Prueba de Wilcoxon para una muestra {visibility="uncounted"}

```{r echo=T, eval=T, error=T}
# Primero recreo la tabla de Prof. Navarro
felicidad <- data.frame(before = c(30,43,21,24,23,40,29,56,38,16),
                        after = c(6,29,11,31,17,2,31,21,8,21))
felicidad$change <- felicidad$after - felicidad$before

wilcox.test(felicidad$change, mu = 0)
```

## Prueba de Wilcoxon para dos muestras

::: incremental
-   Regresando al ejemplo de la tabla de datos `genderweight`, supongamos que estos no están normalmente distribuidos.

-   Usaremos la prueba de Wilcoxon para muestras independientes para ver si existe diferencia entre los pesos de hombres y mujeres.
:::

. . .

```{r echo=T, eval=T, error=T}
wilcox.test(genderweight$weight ~ genderweight$group, paired = F)
```

## Autoevaluación \# 11

1)    Con el vector de nombre `colon` que creaste en la anterior autoevaluación, aplica una prueba de Wilcoxon para una muestra bajo la hipótesis de que la mediana de los días de superviviencia de un paciente con cáncer de colon es de 370 días.

2)    A partir de la tabla de datos de felicidad de la Prof. Navarro, lleva a cabo una prueba de Wilcoxon para dos muestras emparejadas de la felicidad de los estudiantes antes y después de recibir una clase de Estadística. Compara el resultado con la prueba de una muestra que usé de ejemplo. ¿Por qué no hay diferencia?.

# Análisis de Varianza (ANOVA)

## Introducción

::: incremental
-   Hasta el momento nos hemos enfocado a los casos donde comparamos las medias entre dos grupos.

-   Pero es más común el evaluar distintos tratamientos al mismo tiempo, como ya vimos en el módulo 2 del curso.

-   Para ello, contamos con el ANOVA, desarrollado por el estadístico Ronald Fisher a inicios del siglo 20, y que sin duda es el método estadístico más usado hoy en día.

-   Su nombre puede ser confuso. [El objetivo de un ANOVA es el de determinar la existencia de diferencias entre las medias aritméticas de las muestras representativas de $n$ poblaciones (o en términos más precisos, tratamientos).]{.fragment}
:::

## Supuestos del ANOVA {.smaller}

::: incremental
1.  Independencia de los datos: conseguida mediante una correcta randomización y definición del experimento.

2.  Homogeneidad de las varianzas: la varianza entre los tratamientos es la misma.

3.  **Normalidad**: [pero, ¿de qué exactamente?]{.fragment}

-   Siempre ha existido una confusión de este supuesto. Cómo vimos antes, la normalidad es un requisito para conducir pruebas t, y lo es también para el ANOVA.

-   Muchos libros de texto y otros recursos, mencionan que los datos de cada tratamiento deben ser normalmente distribuidos para llevar a cabo un ANOVA. [Esto es cierto e impráctico a la vez.]{.fragment}

-   Mencionamos que como mínimo deberíamos contar con 3 repeticiones por tratamiento. [Pero, ¿son 3 repeticiones suficientes para alcanzar la normalidad?]{.fragment}

-   Es común el sugerir el llevar a cabo una prueba de normalidad antes de un ANOVA, pero esto tiene varios problemas que supongo no te han dicho antes:

    -   Cada tratamiento tiene su propia media, en caso de medias muy distantes entre sí, la prueba puede fallar.

    -   En su lugar, podrías correr una prueba por cada tratamiento. Esto solo funciona con un considerable número de observaciones/tratamiento (3 no son suficientes).
:::

## Supuestos del ANOVA {.smaller visibility="uncounted"}

::: incremental
-   Esta confusión nos puede llevar a soluciones erróneas como transformar datos, borrar outliers o utilizar pruebas no paramétricas innecesariamente.

-   Entonces, ¿**normalidad** de qué?

-   De los residuos estandarizados!... [¿Qué es un residual?]{.fragment}

    -   Un residual es la diferencia entre una observación y su predicción

    -   Un residual estandarizado resulta de la división del residual para la raíz cuadrada de la predicción

    -   La distribución muestral de los residuos estandarizados tiene media 0 y desviación estándar 1

-   Y es sobre esta distribución que los valores críticos del ANOVA (valores F) son calculados. Es decir, estos no dependen enteramente de los datos originales, por lo tanto los datos originales no tienen que ser necesariamente normalmente distribuidos.

-   Pero, ¿por qué la confusión? [Solo cuando el número de observaciones es lo suficientemente grande (y ya sabemos que distribución tiene la media muestral cuando el número incrementa), se tiene la certeza que los residuos serán normalmente distribuidos.]{.fragment}

-   En resumen, es mejor chequear la normalidad después que realizamos el ANOVA.
:::

## El dataset de recursos por depredación

![](images/frog.jpg){fig-align="center"}

::: footer
Imagen tomada por [David Mark](https://pixabay.com/users/12019-12019/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=69813){target="_blank"} de [Pixabay](https://pixabay.com//?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=69813){target="_blank"}
:::

## El dataset de recursos por depredación {.smaller visibility="uncounted"}

::: incremental
-   Los datos que usaremos en esta y otras secciones corresponden a un experimento del [Prof. Justin C. Touchon](https://www.jstor.org/stable/23436298){target="_blank"} acerca de la interacción entre predadores y recursos.

-   El experimento consistió de múltiples tanques (mesocosmos) dispuestos al aire libre en Gamboa, Panamá. Los investigadores tenían por objetivo el saber como la variación en la incubación de huevos de la rana arbórea de ojos rojos podría afectar su desarrollo hasta la metamorfosis bajo varias combinaciones de recursos y predadores.

-   Los tratamientos fueron los siguientes:

    -   Edad de incubación: Temprana (`E`: 4 días después de la oviposición) o tardía (`L`: 6 días después de la oviposición).

    -   Predadores: control (`C`), no letal (`NL`: larvas de libélula enjauladas) y letal (`L`: larvas de libélula libres)

    -   Recursos: bajo (`Lo`: 0.75 g) o alto (`Hi`: 1.5 g) de comida suministrados cada 5 días.

-   Los mesocosmos fueron colocados en 8 bloques de 12 tanques cada uno.

-   El experimento inició con 50 renacuajos por tanque y terminó cuando todos los renacuajos alcanzaron la metamorfosis, o murieron.
:::

## El dataset de recursos por depredación {.smaller visibility="uncounted"}

::: incremental
-   Variables de respuesta:

    -   Edad de metaformosis contada desde el día de oviposición (`Age.DPO`).

    -   Edad de salida del agua (`Age.FromEmergence`)

    -   Longitud nariz-cloaca al emerger (`SVL.initial`)

    -   Longitud de la cola al emerger (`Tail.initial`)

    -   Longitud nariz-cloaca al término de la reabsorción de la cola (`SVL.final`)

    -   Peso al término de la reabsorción de la cola (`Mass.final`)

    -   Número de días requeridos por cada metamorfo para reabsorber completamente la cola (`Resorb.days`)

-   18 tanques conteniendo predadores no letales fueron descartados debido al brote de una enfermedad

-   **NOTA:** el dataset original de Touchon contiene alrededor de 2500 observaciones. Sin embargo, para poder usar los datos bajo los supuestos del ANOVA es necesario reducirlos a las medias aritméticas de cada tratamiento por cuanto se tratan de pseudo repeticiones. Esta reducción ya está hecha en el archivo "touchon.csv" disponible con el [resto de materiales extras del curso.](https://mmorenozam.github.io/progR-website/materiales.html){target="_blank"}
:::

## Explorando este dataset

::: incremental
-   Haremos una exploración básica del dataset anteriormente descrito: gráficos de caja y bigote, de barras, de densidad y matrices de dispersión.

-   Como estos datos han sido pre-procesados, omitiremos el mapa de observaciones perdidas.

-   Para esto, aprovecho la oportunidad para introducir otro par de paquetes útiles

-   Como vimos anteriormente, `ggplot2` es una poderosa librería de visualización de datos cuyo uso es relativamente sencillo. Sin embargo, su dominio requiere un poco de tiempo y paciencia. Para quienes quizá deseen una manera más rápida de realizar sus gráficos y solamente tomarse el tiempo en añadir detalles finales, usaremos `ggpubr`.
:::

## Medias aritméticas observadas

```{r echo=T, eval=T, error=T, fig.align = 'center'}
# usaremos nuevamente el paquete `tidycomm` para los estadísticos descriptivos
ranas <- read.csv("touchon.csv")
describe(ranas)
```

## Gráficos de barras {.scrollable}

::: panel-tabset
### Código

```{r echo=T, eval=F, error=T, fig.align = 'center'}
library(ggpubr)
ggbarplot(data = ranas,
          x = "Pred",
          y = "Age.FromEmergence",
          add = "mean_se",
          fill = "Pred")

ggbarplot(data = ranas,
          x = "Res",
          y = "Age.FromEmergence",
          add = "mean_se",
          fill = "Pred")
```

### Gráfico

```{r echo=F, eval=T, error=T, fig.align = 'center', fig.height=6}
library(ggpubr)
ggbarplot(data = ranas,
          x = "Pred",
          y = "Age.FromEmergence",
          add = "mean_se",
          fill = "Pred")

ggbarplot(data = ranas,
          x = "Res",
          y = "Age.FromEmergence",
          add = "mean_se",
          fill = "Res")
```
:::

## Gráficos de barras {.scrollable visibility="uncounted"}

::: panel-tabset
### Código

```{r echo=T, eval=F, error=T, fig.align = 'center'}
p1 <- ggbarplot(data = ranas,
                x = "Pred",
                y = "Age.FromEmergence",
                add = "mean_se",
                fill = "Pred")

p1 + labs(title = "Gráfico de barras de edad desde oviposición",
       subtitle = "Datos del estudio de Prof. Touchon",
       caption = "Gráfica propia",
       x = "Predadores",
       y = "Edad desde oviposición",
       color = "Predador")
```

### Gráfico

```{r echo=F, eval=T, error=T, fig.align = 'center', fig.height=6}
p1 <- ggbarplot(data = ranas,
                x = "Pred",
                y = "Age.FromEmergence",
                add = "mean_se",
                fill = "Pred")

p1 + labs(title = "Gráfico de barras de edad desde oviposición",
       subtitle = "Datos del estudio de Prof. Touchon",
       caption = "Gráfica propia",
       x = "Predadores",
       y = "Edad desde oviposición (d)",
       fill = "Predador")
```
:::

## Gráficos de caja y bigote {.scrollable}

::: panel-tabset
### Código

```{r echo=T, eval=F, error=T, fig.align = 'center'}
ggboxplot(data = ranas,
          x = "Pred",
          y = "Age.FromEmergence",
          fill = "Pred")

ggboxplot(data = ranas,
          x = "Res",
          y = "Age.FromEmergence",
          fill = "Res")
```

### Gráfico

```{r echo=F, eval=T, error=T, fig.align = 'center', fig.height=6}
ggboxplot(data = ranas,
          x = "Pred",
          y = "Age.FromEmergence",
          fill = "Pred")

ggboxplot(data = ranas,
          x = "Res",
          y = "Age.FromEmergence",
          fill = "Res")
```
:::

## Gráficos de densidad {.scrollable}

::: panel-tabset
### Código

```{r echo=T, eval=F, error=T, fig.align = 'center'}
ggdensity(data = ranas,
          x = "Age.FromEmergence", 
          add = "mean", 
          rug = "true", 
          color = "Pred", 
          fill = "Pred")

ggdensity(data = ranas,
          x = "Age.FromEmergence", 
          add = "mean", 
          rug = "true", 
          color = "Res", 
          fill = "Res")
```

### Gráfico

```{r echo=F, eval=T, error=T, fig.align = 'center', fig.height=6}
ggdensity(data = ranas,
          x = "Age.FromEmergence", 
          add = "mean", 
          rug = "true", 
          color = "Pred", 
          fill = "Pred")

ggdensity(data = ranas,
          x = "Age.FromEmergence", 
          add = "mean", 
          rug = "true", 
          color = "Res", 
          fill = "Res")
```
:::

## Matriz de dispersión {.scrollable}

::: panel-tabset
### Código

```{r echo=T, eval=F, error=T, fig.align = 'center'}
library(GGally)
ranas_matriz <- ranas[,c(6:12)]
ggpairs(ranas_matriz)
```

### Gráfico

```{r echo=F, eval=T, error=T, fig.align = 'center'}
library(GGally)
ranas_matriz <- ranas[,c(6:12)]
ggpairs(ranas_matriz)
```
:::

## ANOVA de una vía {.smaller}

::: incremental
-   ANOVA de una vía se refiere cuando tenemos más de dos tratamientos que están definidos por un solo factor a la vez.

-   Usando los datos del Prof. Touchon, vamos a ilustrar el caso del ANOVA de una vía. Para ello, vamos a considerar lo siguiente

    -   Supongamos que estamos interesados en saber si existe alguna diferencia entre la edad de salida del agua `Age.FromEmergence` determinada por los predadores:

    -   Los niveles del factor predadores son:

        -   Predadores no letales `NL`

        -   Predadores letales `L`

        -   Control (sin predadores) `C`

-   La $H_0$ en todo ANOVA es simplemente que no existe diferencia entre $n$ tratamientos, y la $H_a$ es que al menos uno de los tratamientos tiene una media distinta.
:::

## ANOVA en R

::: incremental
-   Existen dos formas de llevar a cabo ANOVA en R:

    1.  Crear un modelo lineal con la función `lm` y luego el ANOVA con la función `anova` sobre el objeto producto de `lm`.

    2.  Aplicar directamente la función `aov` sobre nuestros datos.

-   Ambas funciones (`lm` y `aov`) tienen la misma sintaxis. [Personalmente prefiero la primera opción.]{.fragment}

-   Adicionalmente, el paquete `car` ofrece la función `Anova`. El resultado de ambas es prácticamente el mismo para la mayoría de modelos. [Sin embargo, personalmente prefiero `Anova` ya que permite realizar correcciones cuando tenemos datos no balanceados.]{.fragment}
:::

## ANOVA de una vía en R

::: columns
::: {.column .fragment width="50%"}
Opción 1

```{r echo=T, eval=F, error=T, fig.align = 'center'}
#| code-line-numbers: "1|2|3|4"
library(car)
lm1 <- lm(Age.FromEmergence ~ Pred, data = ranas)
Anova(lm1)
```
:::

::: {.column .fragment width="50%"}
Opción 2

```{r echo=T, eval=F, error=T, fig.align = 'center'}
#| code-line-numbers: "1|2|3"
anova1 <- aov(Age.FromEmergence ~ Pred, data = ranas)
summary(anova1)
```
:::
:::

::: columns
::: {.column .fragment width="50%"}
```{r echo=F, eval=T, error=T, fig.align = 'center'}
library(car)
lm1 <- lm(Age.FromEmergence ~ Pred, data = ranas)
Anova(lm1)
```
:::

::: {.column .fragment width="50%"}
```{r echo=F, eval=T, error=T, fig.align = 'center'}
anova1 <- aov(Age.FromEmergence ~ Pred, data = ranas)
summary(anova1)
```
:::
:::

## Diagnósticos del ANOVA

::: incremental
-   Antes de conducir pruebas formales para los supuestos del ANOVA, es preciso darle un vistazo a diagnósticos visuales que podemos obtener del mismo.

-   El ANOVA es un caso de regresión lineal (con predictores categóricos), por lo que en esta sección nos centraremos en la interpretación de estos diagnósticos desde la perspectiva del ANOVA.

-   En el apartado de regresión lineal volveremos a profundizar en las interpretaciones de los mismos para ese caso determinado.

-   Para acceder a estos diagnósticos, basta usar la función `plot` sobre el objeto donde guardamos los resultados del modelo `lm1`.
:::

## Diagnósticos del ANOVA {visibility="uncounted"}

```{r echo=T, eval=F, error=T, fig.align = 'center', fig.width=5}
lm1 <- lm(Age.FromEmergence ~ Pred, data = ranas)
par(mfrow = c(2, 2))
plot(lm1)
par(mfrow = c(1, 1))
```

## Diagnósticos del ANOVA {visibility="uncounted"}

```{r echo=F, eval=T, error=T, fig.align = 'center', fig.width=6}
par(mfrow = c(2, 2))
plot(lm1)
par(mfrow = c(1, 1))
```

## Diagnósticos del ANOVA {.smaller visibility="uncounted"}

::: {.columns .v-center-container}
::: {.column .fragment width="40%"}
```{r echo=F, eval=T, error=T, fig.height=6, fig.width=6}
plot(lm1, 1)
```
:::

::: {.column .fragment width="60%"}
**Residuos vs. Valores ajustados**

En este plot podemos evidenciar departuras del supuesto de la homocedasticidad. Idealmente, la línea roja que se muestra debería ir a lo largo de la horizontal en la coordenada cero del eje y (sobre la línea entrecortada).
:::
:::

## Diagnósticos del ANOVA {.smaller visibility="uncounted"}

::: {.columns .v-center-container}
::: {.column .fragment width="40%"}
```{r echo=F, eval=T, error=T, fig.height=6, fig.width=6}
plot(lm1, 2)
```
:::

::: {.column .fragment width="60%"}
**Gráfico Q-Q**

A diferencia del gráfico Q-Q que vimos para las pruebas t, en el eje y de este mismo gráfico para el ANOVA (y regresión lineal) se representan los residuos estandarizados. La interpretación es la misma: idealmente los puntos deberían ir a lo largo de la diagonal. Cuando no es así, evidencia una violación del supuesto de la normalidad.
:::
:::

## Diagnósticos del ANOVA {.smaller visibility="uncounted"}

::: {.columns .v-center-container}
::: {.column .fragment width="40%"}
```{r echo=F, eval=T, error=T, fig.height=6, fig.width=6}
plot(lm1, 3)
```
:::

::: {.column .fragment width="60%"}
**Raíz cuadrada de los residuos estandarizados vs. Valores ajustados**

Similar al primer diagnóstico, en el caso del ANOVA, nos da una idea de posibles departuras de la homogeneidad de las varianzas. La línea roja idealmente debería ser completamente recta.
:::
:::

## Diagnósticos del ANOVA {.smaller visibility="uncounted"}

::: {.columns .v-center-container}
::: {.column .fragment width="40%"}
```{r echo=F, eval=T, error=T, fig.height=6, fig.width=6}
plot(lm1, 5)
```
:::

::: {.column .fragment width="60%"}
**Residuos vs. Apalancamiento**

Aquellos puntos que estén etiquetados con números son mostrados como posibles outliers bajo dos criterios:

-   Están por fuera de los límites de la regla del rango intercuartílico (IQR), y

-   Marcados como outliers con influencia de apalancamiento mediante la prueba de Cook (distancia de Cook).

El segundo criterio es un argumento sólido para remover outliers.
:::
:::

## Transformaciones

```{r echo=T, eval=F, error=T, fig.align = 'center', fig.width=6}
lm2 <- lm(log(Age.FromEmergence) ~ Pred, data = ranas)
par(mfrow = c(2, 2))
plot(lm2)
par(mfrow = c(1, 1))
```

## Transformaciones {visibility="uncounted"}

```{r echo=F, eval=T, error=T, fig.align = 'center', fig.width=6}
lm2 <- lm(log(Age.FromEmergence) ~ Pred, data = ranas)
par(mfrow = c(2, 2))
plot(lm2)
par(mfrow = c(1, 1))
```

## Prueba formal de normalidad

::: incremental
-   Como vimos, después de aplicar la transformación logarítmica el gráfico Q-Q mejoró considerablemente.

-   Para estar seguros, podemos correr un test formal sobre los residuos del modelo con la ayuda del paquete `olsrr` mediante su función `ols_test_normality`.
:::

. . .

```{r echo=T, eval=T, error=T, fig.align = 'center', fig.width=6}
library(olsrr)
ols_test_normality(lm2)
```

## Prueba formal de normalidad {visibility="uncounted"}

::: incremental
-   O también podemos calcular la prueba de Shapiro-Wilk con funciones base de R
:::

. . .

```{r echo=T, eval=T, error=T, fig.align = 'center', fig.width=6}
residuos <- resid(lm2)
shapiro.test(residuos)
```

## Homogeneidad de las varianzas en ANOVA

::: incremental
-   La prueba más usada para chequear la homogeneidad de varianzas de un ANOVA es la de Levene.

-   Para ello utilizaremos la función `leveneTest` del paquete `car`. Podemos usar esta función directamente sobre los datos con la misma sintaxis de `lm`, o sobre el objeto `lm2` en el que anteriormente almacenamos el resultado del modelo lineal con la transformación.
:::

. . .

```{r echo=T, eval=T, error=T, fig.align = 'center', fig.width=6}
leveneTest(lm2, center = "mean")
```

## ANOVA de una vía en R (continuación)

::: incremental
-   Así, una vez que hemos transformado para obtener normalidad en los residuos y chequeado la homogeneidad de varianzas, es tiempo de hecharle un vistazo al resultado del ANOVA:
:::

. . .

```{r echo=T, eval=T, error=T, fig.align = 'center', fig.width=6}
Anova(lm2)
```

. . .

-   Por tanto, podemos concluir que al menos uno de los tratamientos es distinto (aceptamos la $H_a$ y rechazamos la $H_0$)

## ¿Qué tan distintos? {.smaller}

::: incremental
-   Preguntas naturales seguidas de estos resultados son: ¿qué tan distintos son los tratamientos entre sí?, ¿puedo acaso ordernarlos de mayor a menor?, ¿existen pares de tratamientos que son iguales?

-   Podemos comenzar con una ayuda visual (ligeramente distinto a nuestro AED, usando la transformación logarítmica)
:::

. . .

::: panel-tabset
### Código

```{r echo=T, eval=F, error=T, fig.align = 'center'}
# usamos ggpubr nuevamente
ranas$log.Age.FromEmergence <- log(ranas$Age.FromEmergence)
ggboxplot(ranas,
          x = "Pred",
          y = "log.Age.FromEmergence",
          add = "jitter",
          color = "Pred")
```

### Gráfico

```{r echo=F, eval=T, error=T, fig.align = 'center', fig.height=4}
ranas$log.Age.FromEmergence <- log(ranas$Age.FromEmergence)
ggboxplot(ranas,
          x = "Pred",
          y = "log.Age.FromEmergence",
          add = "jitter",
          color = "Pred")
```
:::

## Comparaciones múltiples {.smaller}

::: incremental
-   Los métodos de comparaciones múltiples y gráficos de interacción nos ayudan a responder estas preguntas.

-   En el caso de los gráficos de interacción para ANOVA de una vía, no tiene mucho sentido llevarlos a cabo ya que son más útiles para ANOVA de múltiples vías, así que los dejaremos para después.

-   Las comparaciones múltiples más usadas son:

    -   HSD Tukey (*Honestly significant difference*): lleva a cabo todos los pares de comparaciones posibles entre los niveles de un factor.

    -   Prueba de Dunnett: Compara los niveles únicamente con respecto al nivel control dentro del factor.

-   Son conocidas también como pruebas *post-hoc*.

-   En R, una manera de realizar comparaciones múltiples es mediante los paquetes `emmeans` y `multcomp` (este último depende de `multcompView`, así que no olvides instalarla también).
:::

## HSD Tukey {.smaller}

. . .

Calculamos las medias marginales a partir del modelo

```{r echo=T, eval=F, error=T, fig.align = 'center', fig.width=6}
#| code-line-numbers: "1|2|3"
library(emmeans)
ph1 <- emmeans(lm2, specs = "Pred", type = "response")
summary(ph1)
```

## HSD Tukey {.smaller autoanimate="true"}

Calculamos las medias marginales a partir del modelo

```{r echo=T, eval=T, error=T, fig.align = 'center', fig.width=6}
library(emmeans)
ph1 <- emmeans(lm2, specs = "Pred", type = "response")
summary(ph1)
```

. . .

-   Ahora podemos calcular las comparaciones por pares de HSD Tukey

```{r echo=T, eval=T, error=T, fig.align = 'center', fig.width=6}
tukey_comp <- contrast(ph1, specs = "Pred", method = "tukey")
tukey_comp
```

## Prueba de Dunnett {.smaller .scrollable}

. . .

-   Para Dunnett, es importante el establecer el grupo control

```{r echo=T, eval=T, error=T, fig.align = 'center', fig.width=6}
dunnett_comp <- contrast(ph1, specs = "Pred", method = "dunnett", ref = "C")
dunnett_comp
```

. . .

-   Finalmente, otra tabla de resumen de las comparaciones múltiples es la de agrupar las medias aritméticas marginales con números (o letras) de acuerdo a si estas son estadísticamente distintas o no entre si. Para ello podemos usar el paquete `multcomp`:

```{r echo=T, eval=T, error=T, fig.align = 'center', fig.width=6}
# multcomp necesita un paquete extra llamada multcompView
# No olvides instalar multcompView antes de correr este código
library(multcomp)
medias_marginales <- cld(ph1)
medias_marginales
```

## Antes de continuar {.smaller}

::: incremental
-   En este punto, antes de continuar hagamos uso nuevamente del paquete `flextable` para exportar nuestras tablas a Word.
:::

. . .

```{r echo=T, eval=T, error=T, fig.align = 'center', fig.width=6}
library(flextable)
tabla_tukey <- colformat_double(flextable(as.data.frame(tukey_comp)), digits = 3, j = c(2, 3, 6, 7))
tabla_dunnett <- colformat_double(flextable(as.data.frame(dunnett_comp)), digits = 3, j = c(2, 3, 6, 7))
tabla_marginal <- colformat_double(flextable(medias_marginales), digits = 3, j = c(2, 3, 5, 6))
```

. . .

```{r echo=F, eval=T, error=T, fig.align = 'center', fig.width=6}
tabla_tukey 
tabla_dunnett
tabla_marginal
```

## Antes de continuar {.smaller visibility="uncounted"}

. . .

-   La tabla del ANOVA requiere un poquito más de preparación y para ello nos ayudaremos del paquete `rstatix` para agregar los asteriscos de significancia.

```{r echo=T, eval=F, error=T, fig.align = 'center', fig.width=6}
#| code-line-numbers: "1|2|3|4-8|9-10"
library(rstatix)
tabla_anova <- as.data.frame(Anova(lm2))
tabla_anova <- cbind(parametro = row.names(tabla_anova), tabla_anova)
tabla_anova <- add_significance(tabla_anova, 
                 p.col = "Pr(>F)", 
                 output.col = " ",
                 cutpoints = c(0, 0.001, 0.01, 0.05, 0.1, 1),
                 symbols = c("***", "**", "*", ".", "ns"))
tabla_anova <- colformat_double(flextable(tabla_anova), digits = 3, j = c(2, 4, 5))
tabla_anova <- add_footer_lines(tabla_anova, "Códigos Signif. 0 '***', 0.001 '**', 0.1 '*', 0.05 '.', 0.1 'ns'")
```

## Antes de continuar {.smaller visibility="uncounted"}

-   La tabla del ANOVA requiere un poquito más de preparación y para ello nos ayudaremos del paquete `rstatix` para agregar los códigos de significancia.

```{r echo=T, eval=T, error=T, fig.align = 'center', fig.width=6}
library(rstatix)
tabla_anova <- as.data.frame(Anova(lm2))
tabla_anova <- cbind(parametro = row.names(tabla_anova), tabla_anova)
tabla_anova <- add_significance(tabla_anova, 
                 p.col = "Pr(>F)", 
                 output.col = " ",
                 cutpoints = c(0, 0.001, 0.01, 0.05, 0.1, 1),
                 symbols = c("***", "**", "*", ".", "ns"))
tabla_anova <- colformat_double(flextable(tabla_anova), digits = 3, j = c(2, 4, 5))
tabla_anova <- add_footer_lines(tabla_anova, "Códigos Signif. 0 '***', 0.001 '**', 0.1 '*', 0.05 '.', 0.1 'ns'")
tabla_anova
```

## Antes de continuar {visibility="uncounted"}

```{r echo=T, eval=F, error=T, fig.align = 'center', fig.width=6}
save_as_docx("Tabla Anova" = tabla_anova, "Tabla Tukey" = tabla_tukey, "Tabla Dunnett" = tabla_dunnett,
             "Tabla Medias Marginales Esperadas" = tabla_marginal,
             path = "C:/Users/mmore/Documents/cursos_uce_2023/modulos/uce2023-modulo4/anova.docx")
```

![](images/anova_tabla.png){fig-align="center"}

## Gráficos de comparaciones múltiples {.smaller}

::: incremental
-   Hay personas que prefieren tener representaciones visuales de las comparaciones múltiples.

-   Realizar este tipo de gráficos sin embargo solía demandar buena experiencia ya sea en gráficos base o `ggplot2`.

-   Afortunadamente, `rstatix` nos brinda la posibilidad de llevarlos a cabo de una manera relativamente sencilla.

-   La idea es generar un gráfico con las medias marginales observadas de la variable de interés y posicionar sobre este los resultados de las comparaciones múltiples con sus códigos de significancia (o valores p).

-   Las desventajas de esta visualización son:

    -   Tienen mayor sentido realizarlas con HSD Tukey

    -   Cuando el número de pares de comparaciones es muy grande, el gráfico se vuelve más difícil de interpretar que las tablas.

    -   `rstatix` no tiene manera de directamente volver a retransformar variables a sus unidades originales.

-   Otro gráfico de cierta popularidad es el de los grupos de Tukey de las medias marginales (gráficos de barras con los números/letras sobre cada categoría). Para esto utilizaremos además el paquete `stringr`
:::

## Gráficos de comparaciones múltiples {.smaller visibility="uncounted"}

::: panel-tabset
### Código

```{r echo=T, eval=F, error=T, fig.align = 'center'}
#| code-line-numbers: "1|2-4|5-7|8-12|13|14"
ranas$Pred <- factor(ranas$Pred, levels = c("C", "NL", "L"))
bxplot <- ggboxplot(ranas, x = "Pred", 
                    y = "Age.FromEmergence", 
                    color = "Pred")
hsdvals <- emmeans_test(log.Age.FromEmergence ~ Pred, 
                        data = ranas, 
                        p.adjust.method = "mvt")
hsdvals <- add_significance(hsdvals, 
                            p.col = "p.adj", 
                            output.col = "p.adj.signif",
                            cutpoints = c(0, 0.001, 0.01, 0.05, 0.1, 1),
                            symbols = c("***", "**", "*", ".", "ns"))
hsdvals <- hsdvals %>% add_xy_position(x = "Pred")
bxplot + stat_pvalue_manual(hsdvals, y.position = c(120, 130, 140))
```

### Gráfico

```{r echo=F, eval=T, error=T, fig.align = 'center', fig.height=5}
ranas$Pred <- factor(ranas$Pred, levels = c("C", "NL", "L"))
bxplot <- ggboxplot(ranas, x = "Pred", y = "Age.FromEmergence", color = "Pred")
hsdvals <- emmeans_test(log.Age.FromEmergence ~ Pred, data = ranas, p.adjust.method = "mvt")
hsdvals <- add_significance(hsdvals, 
                                p.col = "p.adj", 
                                output.col = "p.adj.signif",
                                cutpoints = c(0, 0.001, 0.01, 0.05, 0.1, 1),
                                symbols = c("***", "**", "*", ".", "ns"))
hsdvals <- hsdvals %>% add_xy_position(x = "Pred")

bxplot + stat_pvalue_manual(hsdvals, y.position = c(120, 130, 140))
```
:::

## Gráficos de comparaciones múltiples {.smaller visibility="uncounted"}

::: panel-tabset
### Código

```{r echo=T, eval=F, error=T, fig.align = 'center'}
#| code-line-numbers: "1|2|3|4-7|8-10|11-13|14-15"
library(stringr)
gruposvals <- as.data.frame(cld(ph1))
gruposvals$Pred <- factor(gruposvals$Pred, levels = c("C", "NL", "L"))
ggplot(gruposvals,
       aes(x = Pred, 
           y = response, 
           fill = Pred)) +
  geom_bar(stat = "identity", 
           show.legend = F, 
           color = "black")+
  geom_errorbar(aes(ymin = response - SE, 
                    ymax = response + SE), 
                width=0.2)+
  geom_text(aes(label=str_trim(.group), 
                y = response+SE, vjust=-0.5))
```

### Gráfico

```{r echo=F, eval=T, error=T, fig.align = 'center', fig.height=5}
library(stringr)
gruposvals <- as.data.frame(cld(ph1))
gruposvals$Pred <- factor(gruposvals$Pred, levels = c("C", "NL", "L"))
ggplot(gruposvals,
       aes(x = Pred, y = response, fill = Pred))+
  geom_bar(stat = "identity", show.legend = F, color = "black")+
  geom_errorbar(aes(ymin = response - SE, ymax = response + SE), width=0.2)+
  geom_text(aes(label=str_trim(.group), y = response+SE, vjust=-0.5))
```
:::

## ANOVA de un diseño desbalanceado {.smaller}

::: incremental
-   Recordemos que 18 tanques con predadores no letales fueron descartados debido al brote de una enfermedad.

-   El diseño original de Touchon era balanceado. Al perderse unidades experimentales, el diseño se le puede denominar como desbalanceado. En otras palabras, el desbalance es la pérdida de observaciones.

-   La mayoría de métodos estadísticos requieren ser corregidos ante observaciones perdidas para poder tener la certeza de que los estimados que obtenemos no sean sesgados.

-   Sin adentrarnos en mayor detalle, uno de los componentes de la tabla de ANOVA es la suma de cuadrados. Existen tres tipos de suma de cuadrados: I, II y III.

-   En breve, las sumas II y III se aconseja sean usadas cuando existen interacciones en el ANOVA.

-   En R, la función `aov` calcula la suma de cuadrados tipo I. Este tipo de suma no es conveniente ante la presencia de desbalance de los datos.

-   En cambio, la función `Anova` del paquete `car`, usa por default el tipo II que es precisamente el recomendado usar ante la presencia de desbalance.

-   En resumen, sí. Hemos utilizado hasta el momento la corrección adecuada para estos datos.
:::

